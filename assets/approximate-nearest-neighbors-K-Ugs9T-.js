import{j as e}from"./index-BKgolIEe.js";const n=[{id:"introduction",title:"Introduction",level:2},{id:"navigable-small-world-nsw",title:"Navigable Small World (NSW)",level:2},{id:"proximity-graph",title:"Proximity Graph",level:3},{id:"nsw-search-algorithm",title:"NSW Search Algorithm",level:3},{id:"hierarchical-navigable-small-world-hnsw",title:"Hierarchical Navigable Small World (HNSW)",level:2},{id:"hierarchical-proximity-graph",title:"Hierarchical Proximity Graph",level:3}],s={title:"Approximate Nearest Neighbors (ANN)"};function i(t){const r={blockquote:"blockquote",h2:"h2",h3:"h3",img:"img",p:"p",strong:"strong",...t.components};return e.jsxs(e.Fragment,{children:[e.jsx(r.h2,{id:"introduction",children:"Introduction"}),`
`,e.jsxs(r.p,{children:[`A traditional relational database can be used to power a RAG system but are unlikely to scale well for projects that require searching across a large number of document vectors.\r
This is because traditional databases typically rely on an `,e.jsx(r.strong,{children:"exhaustive search"}),` process which brings about significant computational overhead\r
to calculate the distance between a query vector and every single document vector in the database.`]}),`
`,e.jsxs(r.p,{children:["Dedicated vector databases approach this problem by employing ",e.jsx(r.strong,{children:"specialized indexing algorithms"})," that organize vectors in a way that enables fast ",e.jsx(r.strong,{children:"approximate searches"}),`.\r
While approximate search techniques may worsen retrieval accuracy, the `,e.jsx(r.strong,{children:"improved search latency"})," is generally worth it when working with large document collections in production."]}),`
`,e.jsx(r.h2,{id:"navigable-small-world-nsw",children:"Navigable Small World (NSW)"}),`
`,e.jsxs(r.p,{children:["Navigable Small World (NSW) is an Approximate Nearest Neighbors (ANN) algorithm that leverages a ",e.jsx(r.strong,{children:"proximity graph"})," to search for a candidate vector that is closest to the query vector."]}),`
`,e.jsx(r.h3,{id:"proximity-graph",children:"Proximity Graph"}),`
`,e.jsxs(r.blockquote,{children:[`
`,e.jsx(r.p,{children:`A proximity graph is a data structure that contains nodes and edges.\r
Each document vector should be mapped to a node in the graph, and edges should be added between nodes to connect the closest ones together.`}),`
`]}),`
`,e.jsx(r.p,{children:e.jsx(r.img,{src:"/images/D7J467UKfw.png",alt:"Proximity Graph"})}),`
`,e.jsx(r.h3,{id:"nsw-search-algorithm",children:"NSW Search Algorithm"}),`
`,e.jsxs(r.p,{children:["How it works is that a ",e.jsx(r.strong,{children:"random candidate node"})," is selected as the ",e.jsx(r.strong,{children:"starting point"}),", and the algorithm ",e.jsx(r.strong,{children:"recursively traverses the closest neighboring node"}),` in the graph.\r
With each traversal, the new node becomes the new candidate, and the process repeats itself until none of the neighbors are closer to the query vector than the current candidate.`]}),`
`,e.jsxs(r.blockquote,{children:[`
`,e.jsx(r.p,{children:"Note that at the final step, we can also choose to return the top-k nearest neighbors to the query vector to retrieve multiple documents."}),`
`]}),`
`,e.jsx(r.p,{children:e.jsx(r.img,{src:"/images/dzQ16XLjoB.png",alt:"NSW Search Algorithm"})}),`
`,e.jsx(r.h2,{id:"hierarchical-navigable-small-world-hnsw",children:"Hierarchical Navigable Small World (HNSW)"}),`
`,e.jsxs(r.p,{children:["The search process can be further improved through the use of a ",e.jsx(r.strong,{children:"hierarchical proximity graph"}),"."]}),`
`,e.jsx(r.h3,{id:"hierarchical-proximity-graph",children:"Hierarchical Proximity Graph"}),`
`,e.jsxs(r.blockquote,{children:[`
`,e.jsx(r.p,{children:`A hierarchical proximity graph is a proximity graph that contains multiple layers that each contain a different number of nodes.\r
These layers are generated by randomly dropping out nodes from the previous layer.`}),`
`]}),`
`,e.jsxs(r.p,{children:[`The traversal process is generally quicker if we start by traversing higher layers that contain the fewest nodes, and then descending to lower layers that have more nodes.\r
The process is more efficient since `,e.jsx(r.strong,{children:"initially"})," at the highest layers, the algorithm makes ",e.jsx(r.strong,{children:"big jumps"})," to get into the approximate neighborhood of the query vector."]}),`
`,e.jsx(r.p,{children:e.jsx(r.img,{src:"/images/oWhIbeQt9Y.png",alt:"Hierarchical Proximity Graph"})}),`
`,e.jsxs(r.p,{children:["While it may be computational expensive to build a good proximity graph, it is generally not a problem since the calculations required ",e.jsx(r.strong,{children:"can be separately precomputed"}),`.\r
The algorithm allows vector search to be `,e.jsx(r.strong,{children:"scalable"})," across billions of vectors."]}),`
`,e.jsx(r.p,{children:e.jsx(r.img,{src:"/images/YppAsgXsdL.png",alt:"Benefits of HNSW"})})]})}function o(t={}){const{wrapper:r}=t.components||{};return r?e.jsx(r,{...t,children:e.jsx(i,{...t})}):i(t)}export{o as default,s as frontmatter,n as toc};
